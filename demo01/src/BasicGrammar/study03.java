package BasicGrammar;

public class study03 {
    /**
     * 修饰符的有关学习
     * 访问修饰符
     * default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。
     * private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）
     * public : 对所有类可见。使用对象：类、接口、变量、方法
     * protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。
     *
     * 非访问修饰符
     * static :修饰静态方法，静态变量，静态代码块时使用，无论一个类实例化多少对象，它的静态变量只有一份拷贝，静态方法不能使用类的非静态变量
     *          对类变量和方法的访问可以直接使用 classname.variablename 和 classname.methodname 的方式访问。
     *
     * final :修饰变量和方法
     * 变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。final 修饰符通常和 static 修饰符一起使用来创建类常量。
     * 方法：父类中的 final 方法可以被子类继承，但是不能被子类重写。声明 final 方法的主要目的是防止该方法的内容被修改。
     *
     * abstract ：定义抽象类和抽象方法
     * 抽象类，不能实例化对象。声明抽象类的目的是将来对该类进行扩充
     * abstract和final不能同时修饰一个类。包含抽象方法的类必须是抽象类，否则编译错误
     * 抽象类中可以包含抽象方法和非抽象方法
     *抽象方法:在类中没有任何实现，具体的实现由子类提供
     * 抽象方法不能定义为final和static
     * 继承抽象方法的子类必须重写所有抽象方法，除非子类也是抽象类
     * 抽象方法以分号结尾
     *
     * synchronized：  锁用于解决线程安全问题，被修饰的方法在同一时间只能被一个线程访问
     * transient：序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。
     * 该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型
     *
     * volatile：  volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。
     * 而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。
     *
     */

    /**
     * 运算符的学习
     * 着重位运算符，其他的都常用，基本都会
     */
    public static void main(String[] args) {
        //位运算符
        int a = 60;//0011 1100
        int b = 13;//0000 1101
        int c = 0;
        //&按位与，二进制下，同为1则返回1，否则返回0
        c = a & b;//即1100 12
        System.out.println(c);
        //&按位或，二进制下，同为0则返回0，否则返回1
        c = a | b;//0011 1101
        System.out.println(c);
        //^按位不等，二进制下，相同则位0，否则1
        c = a ^ b; //0011 0001
        System.out.println(c);
        //~按位取反，0，1呼唤
        c = ~a;  //1100 0011
        System.out.println(c);
        //<< 	按位左移运算符。左操作数按位左移右操作数指定的位数。	A << 2得到240，即 1111 0000
        c= a<<2; //0011 1100 -> 1111 0000
        System.out.println(c);
        //>> 	按位右移运算符。左操作数按位右移右操作数指定的位数。	A >> 2得到15即 1111
        c= a>>2; //0011 1100 -> 0000 1111
        System.out.println(c);
        //>>> 	按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。	A>>>2得到15即0000 1111
        c= a>>>2; //0000 1111
        System.out.println(c);

        /*
        三元运算符
        （？:）
         */
        a = 10;
        // 如果 a 等于 1 成立，则设置 b 为 20，否则为 30
        b = (a == 1) ? 20 : 30;
        System.out.println( "Value of b is : " +  b );

        // 如果 a 等于 10 成立，则设置 b 为 20，否则为 30
        b = (a == 10) ? 20 : 30;
        System.out.println( "Value of b is : " + b );

//        instanceof 运算符,比较对象是否是一个特定的类型
        String name = "James";
        boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真
    }
}
